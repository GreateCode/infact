<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InFact: InFact Framework</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">InFact
   
   </div>
   <div id="projectbrief">Interpreter and factory for easily creating C++ objects at run-time</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">InFact Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="welcome_sec"></a>
Welcome to the InFact Framework!</h2>
<p>InFact makes it easy to construct C++ objects at run-time, using a simple-yet-powerful language that is almost identical to C++.</p>
<h2><a class="anchor" id="contents_sec"></a>
Contents</h2>
<ul>
<li>
<a class="el" href="index.html#quick_start">Quick Start</a> </li>
<li>
<a class="el" href="index.html#dynamic_objs">Dynamic object instantiation</a> <ul>
<li>
<a class="el" href="index.html#cpp_example">An example: The way C++ does it</a> </li>
<li>
<a class="el" href="index.html#details">Some nitty gritty details: declaring factories for abstract types and registering concrete subtypes</a> </li>
<li>
<a class="el" href="index.html#language">The Factory language</a> </li>
<li>
<a class="el" href="index.html#putting_together">Putting it all together</a> </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="quick_start"></a>
Quick Start</h2>
<p>The main class of this library is called <a class="el" href="classinfact_1_1_interpreter.html">Interpreter</a>. This class knows how to read assignment statements from any input stream (string or file) and dynamically construct objects that have been registered using special macros. The <a class="el" href="classinfact_1_1_factory.html">Factory </a> class is the class responsible for constructing these objects on the fly; see the <a class="el" href="classinfact_1_1_factory.html#a8b2771ba4fac39a71cb1d0156ddba7b6">Factory::CreateOrDie </a> method for the gory details.</p>
<p>In order to have the data members initialized for <a class="el" href="classinfact_1_1_factory.html">Factory</a>-constructible objects, one must implement a method called <code>RegisterInitializers</code> (see <a class="el" href="classinfact_1_1_factory_constructible.html#a1c186ded6db298b7a84e5767e87c740f">the empty definition </a> in the <a class="el" href="classinfact_1_1_factory_constructible.html">FactoryConstructible </a> class; for convenience, most concrete <a class="el" href="classinfact_1_1_factory.html">Factory</a>-constructible implementations derive from this class). You can find some examples defined in the files <a class="el" href="example_8h.html">example.h</a> and <a class="el" href="example_8cc.html">example.cc</a>.</p>
<p>You can try out typing assignment statements to the interpreter using the test executable <code>bin/interpreter-test</code>, built automatically when you run <code>make</code>.</p>
<h2><a class="anchor" id="dynamic_objs"></a>
Dynamic object instantiation</h2>
<p>There&rsquo;s a famous quotation of Philip Greenspun known as <a href="http://en.wikipedia.org/wiki/Greenspun&apos;s_Tenth_Rule">Greenspun&rsquo;s Tenth Rule</a>: </p>
<dl class="user"><dt><b>Greenspun&rsquo;s Tenth Rule</b></dt><dd>Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.</dd></dl>
<p>This statement is remarkably true in practice, and no less so here. C++ lacks convenient support for dynamic object instantiation, but the InFact Framework uses a <a class="el" href="classinfact_1_1_factory.html">Factory </a> class and a C++-style (yet simple) syntax.</p>
<h3><a class="anchor" id="cpp_example"></a>
An example: The way C++ does it</h3>
<p>To motivate the C++-style syntax used by the InFact Framework&rsquo;s <a class="el" href="classinfact_1_1_factory.html">Factory </a> class, let&rsquo;s look at a simple example of a C++ class <code>Person</code> and its constructor: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// A class to represent a date in the standard Gregorian calendar.</span>
 <span class="keyword">class </span>Date {
  <span class="keyword">public</span>:
    Date(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day) :
      year_(year), month_(month), day_(day) { }
  <span class="keyword">private</span>:
    <span class="keywordtype">int</span> year_;
    <span class="keywordtype">int</span> month_;
    <span class="keywordtype">int</span> day_;
 };

 <span class="comment">// A class to represent a few facts about a person.</span>
 <span class="keyword">class </span>Person {
  <span class="keyword">public</span>:
    Person(<span class="keyword">const</span> <span class="keywordtype">string</span> &amp;name, <span class="keywordtype">int</span> cm_height, <span class="keyword">const</span> Date &amp;birthday) :
      name_(name), cm_height_(cm_height), birthday_(birthday) { }
  <span class="keyword">private</span>:
   <span class="keywordtype">string</span> name_;
   <span class="keywordtype">int</span> cm_height_;
   Date birthday_;
 };
</pre></div><p> As you can see, the <code>Person</code> class has three data members, one of which happens to be an instance of another class called <code>Date</code>. In this case, all of the initialization of a <code>Person</code> happens in the <em>initialization phase</em> of the constructor&mdash;the part after the colon but before the <em>declaration phase</em> block. By convention, each parameter to the constructor has a name nearly identical to the data member that will be initialized from it. If we wanted to construct a <code>Person</code> instance for someone named &ldquo;Fred&rdquo; who was 180 cm tall and was born January 10th, 1990, we could write the following: </p>
<div class="fragment"><pre class="fragment">   Person fred(<span class="stringliteral">&quot;Fred&quot;</span>, 180, Date(1990, 1, 10));
</pre></div><p>If <code>Person</code> were a <a class="el" href="classinfact_1_1_factory.html">Factory</a>-constructible type in the InFact Framework (and it <b><em>is</em></b>: see <a class="el" href="example_8h.html">example.h</a>), we would be able to specify the following as a <em>specification string</em> to tell the <a class="el" href="classinfact_1_1_factory.html">Factory </a> how to construct a <code>Person</code> instance for Fred: </p>
<div class="fragment"><pre class="fragment">   Person fred = PersonImpl(name(<span class="stringliteral">&quot;Fred&quot;</span>), cm_height(180), birthday(DateImpl(year(1990), month(1), day(10))));
</pre></div><p> As you can see, the syntax is very similar to that of C++. It&rsquo;s kind of a combination of the parameter list and the initialization phase of a C++ constructor. Unfortunately, we can&rsquo;t get this kind of dynamic instantiation in C++ for free; we need some help from the programmer. However, we&rsquo;ve tried to make the burden on the programmer fairly low, using just a couple of macros to help declare a <a class="el" href="classinfact_1_1_factory.html">Factory </a> for an abstract base class, as well as to make it easy to make that <a class="el" href="classinfact_1_1_factory.html">Factory </a> aware of the concrete subtypes of that base class that it can construct.</p>
<h3><a class="anchor" id="details"></a>
Some nitty gritty details: declaring factories for abstract types and registering concrete subtypes</h3>
<p>Every <a class="el" href="classinfact_1_1_factory.html">Factory</a>-constructible abstract type needs to declare its factory via the <a class="el" href="factory_8h.html#a01b208854b036ee1381a9289186ff3c2">IMPLEMENT_FACTORY</a> macro. For example, since the InFact Framework uses a <a class="el" href="classinfact_1_1_factory.html">Factory </a> to construct concrete instances of the abstract type <a class="el" href="classinfact_1_1_animal.html">Animal </a>, the line </p>
<div class="fragment"><pre class="fragment">   <a class="code" href="factory_8h.html#a01b208854b036ee1381a9289186ff3c2" title="Provides the necessary implementation for a factory for the specified BASE class type.">IMPLEMENT_FACTORY</a>(Animal)
</pre></div><p> appears in the file <code>feature-extractor.C</code>. (It is unfortunate that we have to resort to using macros, but the point is that the burden on the programmer to create a factory is extremely low, and therefore so is the risk of introducing bugs.)</p>
<p>By convention every <a class="el" href="classinfact_1_1_factory.html">Factory</a>-constructible abstract type defines one or two macros in terms of the <a class="el" href="factory_8h.html#a0b09e4aaef613d7556c07875c7d5a029">REGISTER_NAMED</a> macro defined in <a class="el" href="">factory.H</a> to allow concrete subtypes to register themselves with the <a class="el" href="classinfact_1_1_factory.html">Factory</a>, so that they may be instantiated. For example, since the <a class="el" href="classinfact_1_1_animal.html">Animal </a> class is an abstract base class in the InFact Framework that has a <a class="el" href="classinfact_1_1_factory.html">Factory</a>, in feature-extractor.H you can find the declaration of a macro, <a class="el" href="example_8h.html#a8373608da8a006b760cbb66b6205fffe">REGISTER_ANIMAL</a>. The <a class="el" href="classinfact_1_1_cow.html">Cow </a> class is a concrete subclass of <a class="el" href="classinfact_1_1_animal.html">Animal</a>, and so it registers itself with <a class="el" href="classinfact_1_1_factory.html">Factory</a>&lt;<a class="el" href="classinfact_1_1_animal.html">Animal</a>&gt; by having </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="example_8h.html#a8373608da8a006b760cbb66b6205fffe" title="Registers the Animal  with the specified subtype TYPE and NAME with the Animal  Factory.">REGISTER_ANIMAL</a>(Cow) 
</pre></div><p> in <code>cow.C</code>. That macro expands to </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="factory_8h.html#a0b09e4aaef613d7556c07875c7d5a029" title="This macro registers the concrete subtype TYPE with the specified factory for instances of type BASE;...">REGISTER_NAMED</a>(Cow, Cow, Animal) 
</pre></div><p> which tells the <a class="el" href="classinfact_1_1_factory.html">Factory</a>&lt;Animal&gt; that there is a class <code>Cow</code> whose &ldquo;factory name&rdquo; (the string that can appear in <em>specification strings</em>&mdash;more on these in a moment) is <code>"Cow"</code> and that the class <a class="el" href="classinfact_1_1_cow.html">Cow </a> is a concrete subclass of <a class="el" href="classinfact_1_1_animal.html">Animal </a>, <em>i.e.</em>, that it can be constructed by <code>Factory&lt;Animal&gt;</code>, as opposed to some other <code>Factory</code> for a different abstract base class.</p>
<p>Every <a class="el" href="classinfact_1_1_factory.html">Factory</a>-constructible abstract type must also specify two methods, a <code>RegisterInitializers(Initializers&amp;)</code> method and an <code>Init(const string&amp;)</code> method. Both methods are guaranteed to be invoked, in order, just after construction of every object by the <a class="el" href="classinfact_1_1_factory.html">Factory</a>. To reduce the burden on the programmer, you can derive your abstract class from <a class="el" href="classinfact_1_1_factory_constructible.html">FactoryConstructible </a>, which implements both methods to do nothing. (All of the abstract base classes that can be constructed via Factory in the InFact Framework already do this.) For most concrete subtypes, most of the work of initialization is done inside the factory to initialize registered data members, handled by the class&rsquo;s <code>RegisterInitializers(Initializers&amp;)</code> method. The implementation of this method generally contains a set of invocations to the various <code>Add</code> methods of the <a class="el" href="classinfact_1_1_initializers.html">Initializers </a> class, &ldquo;registering&rdquo; each variable with a name that will be recognized by the <a class="el" href="classinfact_1_1_factory.html">Factory </a> when it parses the specification string. When member initializations are added to an <a class="el" href="classinfact_1_1_initializers.html">Initializers </a> instance, they are optional by default. By including a third argument that is <code>true</code>, one may specify a member whose initialization string <em>must</em> appear within the specification. If it does not contain it, a runtime error will be raised.</p>
<p>For completeness, post&ndash;member-initialization may be performed by the class&rsquo;s <code>Init(const string &amp;)</code> method, which is guaranteed to be invoked with the complete string that was parsed by the <a class="el" href="classinfact_1_1_factory.html">Factory</a>. The code executed by a class&rsquo; <code>Init(cosnt string &amp;)</code> method is very much akin to the <em>declaration phase</em> of a C++ constructor, because it is the code that gets executed just after the members have been initialized.</p>
<p>For example, <a class="el" href="classinfact_1_1_animal.html">Animal </a> instances are <a class="el" href="classinfact_1_1_factory.html">Factory</a>-constructible, and so the <a class="el" href="classinfact_1_1_animal.html">Animal </a> class ensures its concrete subclasses have a <a class="el" href="classinfact_1_1_factory_constructible.html#a1c186ded6db298b7a84e5767e87c740f">RegisterInitializers </a> method and an <a class="el" href="">Init </a> method by being a subclass of <a class="el" href="classinfact_1_1_factory_constructible.html">infact::FactoryConstructible</a>. As we saw above, <a class="el" href="classinfact_1_1_cow.html">Cow </a> is a concrete subtype of <a class="el" href="classinfact_1_1_animal.html">Animal</a> . That class has two data members that can be initialized by a factory, one required and one optional. To show you how easy it is to &ldquo;declare&rdquo; data members that need initialization, here is the exact code from the <a class="el" href="classinfact_1_1_cow.html#a8fbdb40e5f983cd20f2caa15b72a227b">Cow::RegisterInitializers </a> method: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> RegisterInitializers(Initializers &amp;initializers) {
   <span class="keywordtype">bool</span> required = <span class="keyword">true</span>;
   initializers.Add(<span class="stringliteral">&quot;name&quot;</span>, &amp;name_, required);
   initializers.Add(<span class="stringliteral">&quot;age&quot;</span>,  &amp;age_);
 }
</pre></div><p> The above code says that the <a class="el" href="classinfact_1_1_cow.html">Cow </a> has a data member <code>name_</code>, which happens to be an <code>string</code>, that is required to be initialized when an <a class="el" href="classinfact_1_1_cow.html">Cow </a> instance is constructed by a <a class="el" href="classinfact_1_1_factory.html">Factory</a>, and that the name of this variable will be <code>"name"</code> as far as the factory is concerned (<em>i.e.</em>, no underscore character, which is the convention). It also says that it has a data member <code>age_</code>, which happens to be of type <code>int</code>, whose factory name will be <code>"age"</code>, and that is not required to be present in a <em>specification string</em> for an <a class="el" href="classinfact_1_1_cow.html">Cow</a>.</p>
<h3><a class="anchor" id="language"></a>
The Factory language</h3>
<p>As we&rsquo;ve seen, the language used to instantiate objects is quite simple. An object is constructed via a <em>specification string</em> of the following form: </p>
<div class="fragment"><pre class="fragment"> RegisteredClassName(member1(init1), member2(init2), ...) 
</pre></div><p> where <code>RegisteredClassName</code> is the concrete subtype&rsquo;s name specified with the <a class="el" href="factory_8h.html#a0b09e4aaef613d7556c07875c7d5a029">REGISTER_NAMED</a> macro (or, more likely, one of the convenience macros that is &ldquo;implemented&rdquo; in terms of the <a class="el" href="factory_8h.html#a0b09e4aaef613d7556c07875c7d5a029">REGISTER_NAMED</a> macro, such as <a class="el" href="example_8h.html#a8373608da8a006b760cbb66b6205fffe">REGISTER_ANIMAL</a> or <a class="el" href="example_8h.html#a9533639d16f8b0269c286444897ff13d">REGISTER_PET_OWNER</a>). The comma-separated list inside the outermost set of parentheses is the set of <em>member initializations</em>, which looks, as we saw <a class="el" href="index.html#cpp_example">above</a>, intentionally similar to the format of a C++ constructor&rsquo;s initialization phase. The names of class members that can be initialized are specified via repeated invocations of the various overloaded <a class="el" href="classinfact_1_1_initializers.html">infact::Initializers</a> <code>Add</code> methods. There is essentially one <code>Add</code> method per primitive C++ type, as well as an <code>Add</code> method for <a class="el" href="classinfact_1_1_factory.html">Factory</a>-constructible types.</p>
<p>If you love Backus-Naur Form specifications, please see the documentation for the <a class="el" href="classinfact_1_1_factory.html#a8b2771ba4fac39a71cb1d0156ddba7b6">Factory::CreateOrDie </a> method for the formal description of the grammar for specification strings.</p>
<p>To continue our example with <a class="el" href="classinfact_1_1_cow.html">Cow </a>, the following are all legal specification strings for constructing <a class="el" href="classinfact_1_1_cow.html">Cow </a> instances: </p>
<div class="fragment"><pre class="fragment"> Cow(name(<span class="stringliteral">&quot;brown&quot;</span>))
 Cow(name(&quot;brown), age(2))
 Cow(age(2), name(&quot;brown&quot;))
 Cow(name(&quot;brown&quot;),)
</pre></div><p> As you can see, the order of member initializers is not important (because each has a unique name), and you can optionally put a comma after the last initializer. The following are <em><b>illegal</b></em> specification strings for <a class="el" href="classinfact_1_1_cow.html">Cow </a> instances: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Illegal specification strings:</span>
 Cow(age(4))
 Cow()
 Cow(name(&quot;fred&quot;), age(&quot;brown&quot;))
</pre></div><p> In the first two cases, the specification strings are missing the required variable <code>name</code>, and in the final case, the optional <code>age</code> member is being initialized, but with an <code>string</code> literal instead of a <code>int</code> literal.</p>
<h3><a class="anchor" id="putting_together"></a>
Putting it all together</h3>
<p>Here is a template illustrating how one creates a <a class="el" href="classinfact_1_1_factory.html">Factory </a> for an abstract base class called &ldquo;<code>Abby</code>&rdquo; and declares a concrete subtype &ldquo;<code>Concky</code>&rdquo; to that Factory. Most users of the InFact Framework are likely only to build concrete subtypes of abstract classes that already have factories, and so those users can safely ignore the <code>abby.H</code> and <code>abby.C</code> files. </p>
<ul>
<li>
<code>abby.H</code> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &quot;factory.H&quot;</span>
 <span class="keyword">class </span>Abby : <span class="keyword">public</span> FactoryConstructible {
   <span class="comment">// .. the code for Abby ...</span>
 };
<span class="preprocessor"> #define REGISTER_NAMED_ABBY(TYPE,NAME) REGISTER_NAMED(TYPE,NAME,Abby)</span>
<span class="preprocessor"> #define REGISTER_ABBY(TYPE) REGISTER_NAMED_ABBY(TYPE,TYPE)</span>
</pre></div> </li>
<li>
<code>abby.C</code> <div class="fragment"><pre class="fragment"> <a class="code" href="factory_8h.html#a01b208854b036ee1381a9289186ff3c2" title="Provides the necessary implementation for a factory for the specified BASE class type.">IMPLEMENT_FACTORY</a>(Abby)
</pre></div> </li>
<li>
<code>concky.H</code> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &quot;abby.H&quot;</span>
 <span class="keyword">class </span>Concky : <span class="keyword">public</span> Abby {
  <span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> RegisterInitializers(Initialiizers &amp;initializers) {
       <span class="comment">// various calls to the overloaded Initializers::Add methods,</span>
       <span class="comment">// one per data member that the Factory can initialize</span>
    }
 };
</pre></div> </li>
<li>
<code> concky.C </code> <div class="fragment"><pre class="fragment"> REGISTER_ABBY(Concky)
</pre></div> </li>
</ul>
<p>So what about Greenspun&rsquo;s Tenth Rule? Well, the idea that initialization strings can themselves contain specification strings suggests that there is a full-blown language being interpreted here, complete with a proper tokenizer and a recursive-descent parser. There is. It is a simple language, and one that is formally specified. To the extent that it mirrors the way C++ does things, it is not quite <em>ad hoc</em>; rather, it is (close to being) an exceedingly small subset of C++ that can be executed dynamically. We <em>hope</em> it is not bug-ridden, but we&rsquo;ll let you, the user, be the judge of that. </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 13 2014 11:20:21 for InFact by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
